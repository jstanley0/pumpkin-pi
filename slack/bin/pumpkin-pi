#!/usr/bin/env ruby

require 'highline/import'
require 'httparty'
require 'slack-rtmapi'
require 'json'
require 'date'
require 'colorize'

CONFIG_FILE = File.expand_path("~/.slack-auth")
PUMPKIN_PI_PATH = File.expand_path("../../../pumpkin-pi", __FILE__)
SOUND_PATH = File.expand_path("../../../sounds", __FILE__)
VOICE_PATH = "/tmp/pumpkin-pi.wav"

PUMPKIN_PI_CHANNEL = 'C0DJ25DGF'

$slack_login_time = nil

class PiWrapper
    def initialize
        @pi = IO.popen([PUMPKIN_PI_PATH, '--interactive'], 'w')
        Signal.trap('INT') do
            if @pi
                puts 'Shutting down pumpkin-pi...'
                send_pi 'exit'
                Process.wait @pi.pid
            end
            exit
        end
    end

    def say(text, color = nil, voice = nil)
        cmd = ["espeak", "-w", VOICE_PATH]
        cmd += ["-v", voice] if voice
        puts cmd.join(' ').cyan
        IO.popen(cmd, 'w') { |io| io.puts(text) }
        send_pi "color loud #{translate_color(color)}" if color
        send_pi "play #{VOICE_PATH}"
        text
    end
    
    def play(file = nil, color = nil)
        file ||= ''
        file = Dir.entries(SOUND_PATH).select { |sound_file| sound_file.downcase.include? file.downcase }.sample
        if file
            send_pi "color loud #{translate_color(color)}" if color
            send_pi "play #{SOUND_PATH}/#{file}"
            "playing \"#{file}\""
        else
            "couldn't find that sound"
        end
    end
    
    def candle(color)
        send_pi "color bright #{translate_color(color)}"
        "candle #{color}"
    end

    private
    
    COLORS = {
        "off" => "#000000",
        "red" => "#ff0000",
        "orange" => "#ff6000",
        "yellow" => "#ffc000",
        "green" => "#00ff00",
        "cyan" => "#00ffff",
        "blue" => "#0000ff",
        "purple" => "#c000ff",
        "white" => "#ffffff"
    }

    def translate_color(color)
        COLORS[color] || color
    end

    def send_pi(command)
        @pi.puts command
        @pi.flush
    end

end

class SlackAPI
  class Error < RuntimeError; end

  class Http
    include HTTParty
    base_uri 'https://slack.com'
    debug_output $stderr if ENV['SLACK_DEBUG'].to_i == 1
  end

  def self.get(path, url_params = {})
    response = Http.get(path, query: url_params.merge(token: $config[:slack_token]))
    $slack_login_time ||= DateTime.httpdate(response.headers['Date']).to_time.to_i
    raise Error.new("#{response.code} #{response.message}") unless response.code == 200
    json = JSON.parse(response.body)
    raise Error.new(response["error"]) unless response["ok"]
    json
  end
end


def check_config
  $config = {}
  config_changed = false
  config_file = File.new(CONFIG_FILE, File::CREAT|File::RDWR, 0600)
  raise "Permissions for #{CONFIG_FILE} are too liberal" if config_file.stat.world_readable?
  data = config_file.read
  unless data.empty?
    $config = JSON.parse(data).tap do |h|
      h.keys.each { |k| h[k.to_sym] = h.delete(k) }
    end
  end

  # log in to slack
  loop do
    if $config[:slack_token]
      begin
        result = SlackAPI.get("/api/auth.test")
        $slack_user_id = result["user_id"]
        puts "Logged into Slack"
        break
      rescue SlackAPI::Error => e
        puts "Slack login failed: #{e.message}"
        $config.delete(:slack_token)
      end
    end
    if !$config[:slack_token]
      config_changed = true
      $config[:slack_token] = ask("Paste your Slack token: ")
    end
  end

  # save config
  if config_changed
    config_file.rewind
    config_file.truncate(0)
    config_file.write $config.to_json
  end
end

def open_im_channel(user_id)
  json = SlackAPI.get "/api/im.open", user: user_id
  json["channel"]["id"]
end

def send_in_channel(channel, text)
  SlackAPI.get "/api/chat.postMessage", channel: channel, username: 'Pumpkin Pi', as_user: false, text: text,
               unfurl_links: false, unfurl_media: false, icon_emoji: ":jack_o_lantern:"
end

# send a direct message to the caller
def pm(message, text)
  send_in_channel(open_im_channel($slack_user_id), text)
end

# reply to the message in channel
def reply(message, text)
  send_in_channel(message["channel"], text)
end


# ...

$slack_user_id = nil
$pi = PiWrapper.new

check_config

$slack_client = SlackRTM::Client.new(websocket_url: SlackRTM.get_url(token: $config[:slack_token]))
$slack_client.on(:message) do |data|
  if data["type"] == "message" && data["channel"] == PUMPKIN_PI_CHANNEL
    next if data['ts'].to_f < $slack_login_time
    text = data["text"]
    if text =~ /\Asay(?::([^: ]+))?(?::([^: ]+))? (.+)\z/i
      reply data, $pi.say($3, $1, $2)
    elsif text =~ /\Aplay(?::([^: ]+))? (.+)\z/i
      reply data, $pi.play($2, $1)
    elsif text =~ /\Acandle(?::([^: ]+))\z/i
      reply data, $pi.candle($1)
    elsif text =~ /\Arandom\z/i
      reply data, $pi.play
    elsif text =~ /\Ahh\z/i
      reply data, $pi.say('Happy Halloween!')
    elsif text =~ /\Ayw\z/i
      reply data, $pi.say("You're welcome! Don't eat it all tonight!")
    elsif text =~ /\Ahello\z/i
      reply data, $pi.say("Hello! I'm the pumpkin down here.")
    end
  end
end

puts "Connected to Slack Real Time Messaging API"

$slack_client.main_loop

